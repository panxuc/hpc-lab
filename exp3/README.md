# 小作业三：测量 OpenMP 并行 for 循环不同调度策略的性能

我使用 `make` 进行编译，并使用 `srun -N 1 ./omp_sched` 提交，即线程数为 1。

对于 OpenMP 的 `static`、`dynamic` 和 `guided` 三种调度模式，我补全的指导语句分别如下：

```cpp
#pragma omp parallel for schedule(static)
#pragma omp parallel for schedule(dynamic)
#pragma omp parallel for schedule(guided)
```

此外，我另外测试了串行不使用 OpenMP 的情况，以及只添加 `#pragma omp parallel for` 而不指定调度模式的情况。

| 调度模式 | Uniform (ms) | 加速比 | Random (ms) | 加速比 |
| :------: | :----------: | :----: | :---------: | :----: |
|   串行   |   1852.33    |  1.00  |   3797.51   |  1.00  |
|  不指定  |   71.6435    | 25.85  |   189.68    | 20.02  |
|  static  |   67.9934    | 27.24  |   190.335   | 19.95  |
| dynamic  |   84.0829    | 22.03  |   171.721   | 22.11  |
|  guided  |   69.2433    | 26.75  |   163.531   | 23.22  |

对于较多且为均匀长度的分段（Uniform），`static` 策略将所有分段平均分块分配给线程，实现了负载均衡，同时分配开销很小，因此耗时最小；而 `dynamic` 策略将分段分配给线程时，每次分配一个分段，因此开销较大，耗时较长；`guided` 策略则是动态调整分段大小，因此介于两者之间。

对于较少且为随机长度的分段（Random），`static` 策略分配给线程的计算量是随机的，分段长度不均匀，负载均衡较差，因此耗时较长；而 `dynamic` 策略实现了完全的负载均衡，同时由于分段数量较少，分配开销不大，因此耗时较小；`guided` 策略进一步减少了分配开销，因此耗时更小。

实验结果基本符合预期。不过在实际实验中发现，多次实验结果会有一定的、有时是不小的波动，可能会对实验结果产生一定的影响。
